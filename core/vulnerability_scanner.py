# CryptoZ/core/vulnerability_scanner.py
#import os
import re
import json
#import hashlib
import logging
from pathlib import Path
from typing import Dict, List, Any
from datetime import datetime

class VulnerabilityScanner:
    """Scanning for vulnerabilities and potential data leaks"""
    def __init__(self, settings):
        self.settings = settings
        self.logger = logging.getLogger(__name__)
        
        # Pattern for finding vulnerable data
        self.patterns = {
            'email': r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b',
            'credit_card': r'\b(?:\d[ -]*?){13,16}\b',
            'ssn': r'\b\d{3}[-\s]?\d{2}[-\s]?\d{4}\b',
            'phone': r'\b(?:\+?1[-.\s]?)?\(?([0-9]{3})\)?[-.\s]?([0-9]{3})[-.\s]?([0-9]{4})\b',
            'api_key': r'(?i)(?:api[_\s]?key|secret|token|password|pass|pwd)[_\s]?:[\s"\']*(?:[a-zA-Z0-9._-]{16,})',
            'private_key': r'-----BEGIN (?:RSA|DSA|EC|OPENSSH) PRIVATE KEY-----',
            'aws_key': r'(?:A3T[A-Z0-9]|AKIA|AGPA|AIDA|AROA|AIPA|ANPA|ANVA|ASIA)[A-Z0-9]{16}',
            'google_api': r'AIza[0-9A-Za-z\\-_]{35}',
            'facebook_token': r'EAACEdEose0cBA[0-9A-Za-z\\+\\/]{100,}',
            'github_token': r'ghp_[0-9a-zA-Z]{36}',
            'slack_token': r'xox[baprs]-([0-9a-zA-Z]{10,48})',
        }
        
        # Keywords for phishing
        self.phishing_keywords = {
            'urgent', 'immediate', 'action required', 'verify', 'confirm',
            'account', 'security', 'suspended', 'locked', 'password', 'login',
            'bank', 'payment', 'invoice', 'money', 'click', 'link', 'free',
            'winner', 'congratulations', 'prize', 'lottery', 'urgent response',
            'important', 'attention', 'warning', 'alert', 'compromised'
        }
        
        # Suspicious domains
        self.suspicious_domains = {
            'goggle.com', 'facebok.com', 'goog1e.com', 'amaz0n.com',
            'micros0ft.com', 'paypa1.com', 'apple-id.com', 'verify-account.com'
        }
        
        # Extensions to scan
        self.scan_extensions = {
            '.txt', '.log', '.json', '.xml', '.html', '.js', 
            '.py', '.java', '.php', '.rb', '.config', '.env',
            '.csv', '.xls', '.xlsx', '.doc', '.docx', '.pdf'
        }
    
    def scan_directory(self, directory_path: str, recursive: bool = True) -> Dict[str, Any]:
        """Scan directory"""
        try:
            directory = Path(directory_path)
            if not directory.exists():
                raise FileNotFoundError(f"Directory not found: {directory_path}")
            
            # Initialization result with correct structure
            results = {
                'scan_info': {
                    'directory': str(directory),
                    'recursive': recursive,
                    'timestamp': datetime.now().isoformat(),
                    'files_scanned': 0,
                    'issues_found': 0
                },
                'files': [],
                'summary': {
                    'total_files': 0,
                    'scanned_files': 0,
                    'issues_found': 0,
                    'issues_by_type': {},
                    'risk_score': 0
                }
            }
            
            files_to_scan = []
            if recursive:
                for ext in self.scan_extensions:
                    files_to_scan.extend(directory.rglob(f'*{ext}'))
            else:
                files_to_scan.extend(directory.glob('*'))
                files_to_scan = [f for f in files_to_scan if f.suffix in self.scan_extensions]
            
            results['summary']['total_files'] = len(files_to_scan)
            
            for file_path in files_to_scan:
                if file_path.is_file():
                    file_result = self._scan_file(file_path)
                    if file_result and 'issues' in file_result and file_result['issues']:
                        results['files'].append(file_result)
                        results['summary']['issues_found'] += len(file_result['issues'])
                    
                    results['summary']['scanned_files'] += 1
            
            # Calculate summary statistics
            if results['files']:  # Only if there are files
                self._calculate_summary_stats(results)
            else:
                # If no files found, set 0
                results['summary']['issues_found'] = 0
                results['summary']['issues_by_type'] = {}
                results['summary']['risk_score'] = 0
            
            # Update total issues found
            results['scan_info']['issues_found'] = results['summary']['issues_found']
            
            self.logger.info(f"Vulnerability scan completed: {results['summary']['issues_found']} issues found in {results['summary']['scanned_files']} files")
            return results
            
        except Exception as e:
            self.logger.error(f"Directory scan error: {e}")
            # Return minimum structure even if error
            return {
                'scan_info': {
                    'directory': directory_path,
                    'recursive': recursive,
                    'timestamp': datetime.now().isoformat(),
                    'files_scanned': 0,
                    'issues_found': 0
                },
                'files': [],
                'summary': {
                    'total_files': 0,
                    'scanned_files': 0,
                    'issues_found': 0,
                    'issues_by_type': {},
                    'risk_score': 0
                }
            }
    
    def _scan_file(self, file_path: Path) -> Dict[str, Any]:
        """Scan file"""
        try:
            # Initialization
            file_info = {
                'path': str(file_path),
                'size': file_path.stat().st_size if file_path.exists() else 0,
                'modified': file_path.stat().st_mtime if file_path.exists() else 0,
                'issues': []  # Garantied to create empty list
            }
            
            # Check extension
            if not file_path.exists() or file_path.suffix.lower() not in self.scan_extensions:
                return file_info
            
            # Read file
            try:
                content = file_path.read_text(encoding='utf-8', errors='ignore')
            except Exception as e:
                file_info['issues'].append({
                    'type': 'file_access',
                    'severity': 'high',
                    'description': f'Cannot read file: {str(e)}'
                })
                return file_info
            
            # Search for patterns
            for issue_type, pattern in self.patterns.items():
                try:
                    matches = list(re.finditer(pattern, content, re.IGNORECASE))
                    for match in matches:
                        file_info['issues'].append({
                            'type': issue_type,
                            'severity': self._get_severity(issue_type),
                            'description': f'Potential {issue_type} detected',
                            'line': self._find_line_number(content, match.start()),
                            'context': content[max(0, match.start()-50):match.end()+50].strip()
                        })
                except re.error as e:
                    self.logger.warning(f"Regex error for {issue_type}: {e}")
                    continue
            
            # Check for phishing
            if self._is_phishing_content(content):
                file_info['issues'].append({
                    'type': 'phishing',
                    'severity': 'high',
                    'description': 'Potential phishing content detected',
                    'confidence': self._phishing_confidence(content)
                })
            
            # Check for suspicious domains
            suspicious_domains = self._find_suspicious_domains(content)
            for domain in suspicious_domains:
                file_info['issues'].append({
                    'type': 'suspicious_domain',
                    'severity': 'high',
                    'description': f'Suspicious domain detected: {domain}',
                    'domain': domain
                })
            
            return file_info
            
        except Exception as e:
            self.logger.error(f"File scan error {file_path}: {e}")
            return {
                'path': str(file_path),
                'issues': [{
                    'type': 'scan_error',
                    'severity': 'critical',
                    'description': f'Scan failed: {str(e)}'
                }]
            }
    
    def _get_severity(self, issue_type: str) -> str:
        """Detect level risk"""
        severity_map = {
            'private_key': 'critical',
            'api_key': 'critical',
            'credit_card': 'critical',
            'ssn': 'critical',
            'aws_key': 'critical',
            'phishing': 'critical',
            'suspicious_domain': 'critical',
            'email': 'medium',
            'phone': 'low',
            'google_api': 'high',
            'facebook_token': 'high',
            'github_token': 'high',
            'slack_token': 'high'
        }
        return severity_map.get(issue_type, 'medium')
    
    def _find_line_number(self, content: str, position: int) -> int:
        if not content or position < 0:
            return 1
        return content[:position].count('\n') + 1
    
    def _is_phishing_content(self, content: str) -> bool:
        """Check for phishing"""
        if not content:
            return False
            
        content_lower = content.lower()
        keyword_count = sum(1 for keyword in self.phishing_keywords if keyword in content_lower)
        
        # Check for urgent words and action words
        urgent_words = sum(1 for word in ['urgent', 'immediate', 'required'] if word in content_lower)
        action_words = sum(1 for word in ['click', 'verify', 'confirm', 'login'] if word in content_lower)
        
        return (keyword_count >= 3) or (urgent_words >= 1 and action_words >= 1)
    
    def _phishing_confidence(self, content: str) -> float:
        """Уровень уверенности в фишинге"""
        if not content:
            return 0.0
            
        content_lower = content.lower()
        score = 0
        
        # Check for keywords
        for keyword in self.phishing_keywords:
            if keyword in content_lower:
                score += 1
        
        # Check for suspicious URLs
        urls = re.findall(r'https?://[^\s<>"]+|www\.[^\s<>"]+', content_lower)
        for url in urls:
            for suspicious in self.suspicious_domains:
                if suspicious in url:
                    score += 3
                    break
        
        return min(score / 10.0, 1.0) * 100
    
    def _find_suspicious_domains(self, content: str) -> List[str]:
        """Find sus domain"""
        if not content:
            return []
            
        urls = re.findall(r'https?://([^\s<>"]+)|www\.([^\s<>"]+)', content)
        suspicious = []
        
        for url_parts in urls:
            domain = (url_parts[0] or url_parts[1]).split('/')[0].lower() if url_parts[0] or url_parts[1] else ''
            # Remove ports and paths
            domain = domain.split(':')[0].split('/')[0] if domain else ''
            
            for suspicious_domain in self.suspicious_domains:
                if domain and suspicious_domain in domain:
                    suspicious.append(domain)
                    break
        
        return list(set(suspicious))  # Unique domains
    
    def _calculate_summary_stats(self, results: Dict[str, Any]):
        """Calculate"""
        try:
            issues_by_type = {}
            total_issues = 0
            
            for file_result in results['files']:
                if 'issues' in file_result:
                    for issue in file_result['issues']:
                        issue_type = issue['type']
                        issues_by_type[issue_type] = issues_by_type.get(issue_type, 0) + 1
                        total_issues += 1
            
            results['summary']['issues_by_type'] = issues_by_type
            
            # Calculate risk score
            risk_score = 0
            severity_weights = {'critical': 10, 'high': 5, 'medium': 3, 'low': 1}
            
            for file_result in results['files']:
                if 'issues' in file_result:
                    for issue in file_result['issues']:
                        risk_score += severity_weights.get(issue['severity'], 1)
            
            results['summary']['risk_score'] = min(risk_score, 100)
            results['summary']['issues_found'] = total_issues
            results['scan_info']['issues_found'] = total_issues
            
        except Exception as e:
            self.logger.error(f"Error calculating summary stats: {e}")
            # Set safe defaults
            results['summary']['issues_by_type'] = {}
            results['summary']['issues_found'] = 0
            results['summary']['risk_score'] = 0
            results['scan_info']['issues_found'] = 0
    
    def export_results(self, results: Dict[str, Any], output_path: str):
        """Export results"""
        try:
            if not results:
                raise ValueError("No results to export")
                
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
            
            with open(output_file, 'w', encoding='utf-8') as f:
                json.dump(results, f, indent=2, ensure_ascii=False)
            
            self.logger.info(f"Scan results exported to {output_path}")
            
        except Exception as e:
            self.logger.error(f"Export error: {e}")
            raise
    
    def get_risk_level(self, risk_score: int) -> str:
        """Get level of risks"""
        if risk_score >= 80:
            return "Critical"
        elif risk_score >= 60:
            return "High"
        elif risk_score >= 40:
            return "Medium"
        elif risk_score >= 20:
            return "Low"
        else:
            return "Not that important"
